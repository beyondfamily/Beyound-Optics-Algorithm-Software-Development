## 代码分析

#### 主界面

调用tkinter创建主界面，并定义一些之后会用到的变量

```python
class MainPage:
    def __init__(self):
        self.root = tkinter.Tk()
        self.root.title('MainPage')
        self.w = self.root.winfo_screenwidth()
        self.h = self.root.winfo_screenheight()
        self.root.geometry("%dx%d" % (self.w, self.h))  #窗口全屏
        self.root['background'] = "white"  #背景白色
        self.root.update()
        self.button_num = 0    #按钮数
        self.line_num = -1     #线条数
        self.lianxian = False  #连线flag
        self.move = False      #移动flag
        self.tiaocan = False   #调参flag
        self.drawbutton_list = []     #绘图区按钮列
        self.line_list = []			#绘图区线路列

        self.create_menu()#定义菜单
        self.control_frame()#定义控制窗
        self.element_frame()#定义元件窗口
        self.draw_frame()#定义绘图窗口

        self.root.mainloop()

```

#### 顶部菜单栏

调用tkinter创建顶部菜单栏

目前还没绑定事件，是个空壳

```python
    def create_menu(self):
        self.menu = tkinter.Menu(self.root)     #建立菜单
        # ------------------文件菜单-------------------------------------------------------#
        self.file_menu = tkinter.Menu(self.menu,tearoff=False)
        self.file_menu.add_command(label='打开',command=self.menu_handle)
        self.file_menu.add_command(label='保存',command=self.menu_handle)
        self.file_menu.add_separator()
        self.file_menu.add_command(label='关闭',command=self.root.quit)
        self.menu.add_cascade(label='文件',menu=self.file_menu)
        # ------------------编辑菜单-------------------------------------------------------#
        self.edit_menu = tkinter.Menu(self.menu,tearoff=False)
        self.edit_menu.add_command(label='复制',command=self.menu_handle)
        self.edit_menu.add_command(label='粘贴',command=self.menu_handle)
        self.edit_menu.add_separator()
        self.edit_menu.add_command(label='设置',command=self.menu_handle)
        self.menu.add_cascade(label='编辑',menu=self.edit_menu)
        # ------------------右键弹出菜单----------------------------------------------------#
        self.pop_menu = tkinter.Menu(self.root,tearoff=False)
        self.pop_menu.add_command(label='复制',command=self.pop_menu_handle)
        self.pop_menu.add_command(label='粘贴', command=self.pop_menu_handle)
        self.pop_menu.add_command(label='删除', command=self.pop_menu_handle)
        self.pop_menu.add_separator()
        self.pop_menu.add_command(label='Beyond Family',command=self.pop_menu_handle)
        self.pop_menu.add_command(label='119484182@qq.com',command=self.pop_menu_handle)

        self.root.config(menu=self.menu)
        self.root.bind('<Button-3>',self.popup_handle)
        # -------------------------------------------------------------------------------#
```

#### 顶部控制区

调用tkinter创建一个Frame并布局在主窗口顶部，作为控制区

添加按钮并绑定相应事件

已完成：打开，保存，运行，连线，移动，调参，示波器

未完成：新建，撤销

![image-20220227141158459](C:\Users\13735665991\AppData\Roaming\Typora\typora-user-images\image-20220227141158459.png)

```python
    def control_frame(self):      #控制区
        self.control_frame = tkinter.Frame(self.root, width=1920,height=50,bg='gray')
        self.control_frame.place(x=0,y=0)
        # --------------------添加控制按钮-------------------------------------------------#
        self.control_button = []
        self.control_button.append(
            tkinter.Button(self.control_frame, text='新建', fg='black', width='5', height='2',font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='打开', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='保存', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='运行', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='连线', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='移动', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='调参', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='撤销', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.control_button.append(
            tkinter.Button(self.control_frame, text='示波器', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.column = 0
        for i in self.control_button:
            i.grid(row=0,column=self.column)
            self.column+=1

        self.control_button[1].bind('<ButtonRelease-1>', lambda event: self.open_handle())  # 绑定打开事件
        self.control_button[2].bind('<ButtonRelease-1>', lambda event: self.save_handle())  # 绑定保存事件
        self.control_button[3].bind('<ButtonRelease-1>', lambda event: self.list_run(event))   #绑定运行事件
        self.control_button[4].bind('<ButtonRelease-1>', lambda event: self.lianxian_handle())  #绑定连线事件
        self.control_button[5].bind('<ButtonRelease-1>', lambda event: self.move_handle())     #绑定拖动事件
        self.control_button[6].bind('<ButtonRelease-1>', lambda event: self.tiaocan_handle())   #绑定调参
        self.control_button[7].bind('<ButtonRelease-1>', lambda event: self.cancel_handle())    #撤销
        self.control_button[8].bind('<ButtonRelease-1>', lambda event: self.Oscilloscope())     #示波器
        # -------------------------------------------------------------------------------#

```

#### 删除事件

未完工

```python
    def delete_element(self):       #删除
        pass
```

#### 撤销事件

目前只能撤销线路，半成品

```python
    def cancel_handle(self):        #撤销 未完成，还需要改动
        if(self.line_num>=0):
            self.canvas.delete(self.line_list[self.line_num])
            self.line_num -= 1
        else:
            pass

```

完善思路(仅为思路，还需要修改其他函数以实现效果)

此外，在撤销时应一并删除相应的节点

```python
	draw_flag = []
    self.total_num = 0
    #绘制元件时，draw_flag.append(1),self.total_num += 1
    #绘制线路时，draw_flag.append(0),self.total_num += 1
    def cancel_handle(self):        #撤销 未完成，还需要改动
        if draw_flag[self.total_num] == 0:
            if(self.line_num>=0):
                self.canvas.delete(self.line_list[self.line_num])
                self.line_num -= 1
                self.total_num -= 1
                #删除线路后应一并删除该线路连接的两节点的连接关系
            else:
                pass
        else:
            if(self.button_num>=0):
                self.canvas.delete(self.drawbutton_list[self.button_num])
                self.button_num -= 1
                self.total_num -= 1
                #此处还需要删除元件相对应的节点
            else:
                pass
    
```

#### 旗帜（flag）

点击控制区的（移动，连线，调参）按钮后，将相应的flag设为True

```python
    def lianxian_handle(self):
        self.lianxian = True
        self.move = False
        self.tiaocan = False


    def move_handle(self):
        self.lianxian = False
        self.tiaocan = False
        self.move = True


    def tiaocan_handle(self):
        self.lianxian = False
        self.move = False
        self.tiaocan = True
```

#### 元件列表

调用tkinter创建一个Frame，布局在主窗口左侧作为元件列表

添加不同的元件并绑定事件，事件内容为双击列表中的元件后在绘图区生成同名元件

当前在绘图区出现两个同样的元件时还无法区分，后续可以在元件名后添加数字以区分

![image-20220227145305411](C:\Users\13735665991\AppData\Roaming\Typora\typora-user-images\image-20220227145305411.png)

```python
    def element_frame(self):   #元件列表区
        self.element_frame = tkinter.Frame(self.root, width=300,height=1030,bg='LightSlateGray')
        self.element_frame.place(x=0,y=50)
        #---------------------下拉菜单--------------------------------------------------#
        self.element_tuple = ('1','2','3')
        self.element_combobox = tkinter.ttk.Combobox(self.element_frame, values= self.element_tuple)
        self.element_combobox.bind('<<ComboboxSelected>>',self.combobox_handle)
        self.element_combobox.place(x=50,y=50)
        #-----------------------------------------------------------------------------#

        # --------------------添加按钮--------------------------------------------------#
        self.button_list = [[],[],[]]
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='发送', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='接收', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='QPSK', fg='black', width='5', height='2' , font=('微软雅黑', 10)))
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='QPSK\n解调', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='PAPR', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='压扩', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='QAM', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[0].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))

        self.button_list[1].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[1].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[1].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[1].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[1].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[1].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))

        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        self.button_list[2].append(
            tkinter.Button(self.element_frame, text='undef', fg='black', width='5', height='2' ,font=('微软雅黑', 10)))
        # -----------------------------------------------------------------------------#

        # -----------------------------布局按钮--------------------------------------------#
        num = 0
        self.label_x = [50,150,50,150,50,150,50,150,50,150,50,150]
        self.label_y = [150,150,250,250,350,350,450,450,550,550,650,650]
        for i in self.button_list:   #当前button_list有3列，每列都有一定数量的按钮，此处i用于遍历三列按钮中的每一列
            num1 = 0
            for button in i:       #为当前列中的所有按钮绑定事件并布局
                button.bind('<Double-Button-1>',lambda event:self.pop_element(event))
                button.place(x=self.label_x[num1],y=self.label_y[num1])
                num1 += 1

            if num != 0:          #仅第一列按钮显示在列表去，其他列的代码隐藏
                for button in i:
                    button.place_forget()   #隐藏其他按钮列表
            num += 1

        self.now = 0   #此刻显示的按钮列表
        # --------------------------------------------------------------------------------#
```

#### 元件列表的下拉菜单

用去切换当前显示的按钮列

毕老师要求做成文件夹形式

毛林涛同学已经完成文件夹的形式，把此处代码替换掉即可

```python
def combobox_handle(self,event):
    for button in self.button_list[self.now]:   #隐藏当前显示的按钮列表
        button.place_forget()
    # ----------------显示选择的按钮列表--------------------------------------------------#
    self.now = int(self.element_combobox.get())-1
    num = 0
    for button in self.button_list[self.now]:
        button.place(x=self.label_x[num], y=self.label_y[num])
        num += 1
    # ---------------------------------------------------------------------------------#
```

#### 绘图区

调用tkinter创建一个Frame，布局在窗口右下作为绘图区

调用tkinter创建一个Canvas覆盖Frame，用于绘制线路

![image-20220227145339106](C:\Users\13735665991\AppData\Roaming\Typora\typora-user-images\image-20220227145339106.png)

```python
    def draw_frame(self):   #画图区
        self.element_list = []    #绘图区的元件列表
        self.grid1 = np.zeros(2)   #用于保存点击的元件的坐标
        self.grid2 = np.zeros(2)   #用于保存点击的元件的坐标
        self.element_name1 = ''    #用于保存点击的元件的名称
        self.element_name2 = ''    #用于保存点击的元件的名称
        self.position = 0          #以前写的，忘了具体作用，删了也不影响正常运行，但为了保险还是留着
        self.flag = False          #flag,用于连线

        self.draw_frame = tkinter.Frame(self.root, width=1620,height=830,bg='white')
        self.draw_frame.place(x=300,y=50)
        # -------------------------建立绘图的Canvas--------------------------------------#
        self.canvas = tkinter.Canvas(self.draw_frame,width=1620,height=830,bg='Gray')
        self.canvas.bind("<Button-1>", lambda event: self.draw_lines(event))
        self.canvas.place(x=0,y=0)
        # -----------------------------------------------------------------------------#
```

#### exec()

exec()可以运行字符串格式的命令

由于通过 event.widget['text']  得到的元件名为字符串，在很多操作中不方便使用，所以使用exec()函数

```python
#例如此处得到了两个元件名name1 = 'QPSK',name2 = '解调'
#要使self.QPSK.next = self.解调
#若用self.name1.next = self.name2,则会报错
#可以用if(name1 == 'QPSK' and name2 == '解调'): self.QPSK.next = self.解调
#但是随着元件增多，需要的if语句就会成指数增长，十分繁琐
#这个问题困扰了我很久，直到发现了exec(),使用exec()可以很简单的解决这一问题
cmd = 'self.' + name1 + '.next = self.' + name2	      	  
#此时cmd = 'self.QPSK.next = self.解调'
exec(cmd)    #运行字符串格式的命令
```



#### 生成绘图区元件事件

用于生成绘图区元件的事件，绑定在元件列表区的按钮上，双击后在绘图区生成同名元件并创建一个同名节点

节点用于保存元件的各项数据，包括：名称，输入，输出，连接的下一个元件，各项参数及坐标

```python
def pop_element(self,event): #双击元件列表中的按钮后在绘图区生成相应的按钮
    button = event.widget['text']      #得到触发事件的按钮名称
    self.drawbutton_list.append(
        tkinter.Button(self.draw_frame, text=button, fg='black', width='5', height='2' , font=('微软雅黑', 10)))                               #在绘图区添加同名元件
    #----------------------------------------------------------------------------------
    #由于有些元件名称较长，按钮无法完全显示，所以添加了\n分行显示
    #此处代码用于去除元件名中的\n，防止后续操作出现错误
    #python自带的strip()函数有类似功能，但效果不好，所以自己写了
    #这部分代码在多处有使用，记住功能即可
    button_name = ''      
    for i in button:
        if i == '\n':
            pass
        else:
            button_name = button_name + i
    #----------------------------------------------------------------------------------
    #创建同名节点，用于保存各项数据
    cmd = 'self.' + button_name + ' = Node(\'' + button_name + '\')'
    exec(cmd)
    #----------------------------------------------------------------------------------
    self.drawbutton_list[self.button_num].place(x=50+60*(self.button_num%15),y=100)
    self.drawbutton_list[self.button_num].bind('<ButtonRelease-1>',lambda event:self.element_handle(event)) #绑定连线事件
    self.drawbutton_list[self.button_num].bind('<B1-Motion>', lambda event:self.element_move(event))  
#绑定移动事件
    #----------------------------------------------------------------------------------------------
    #根据按钮名称绑定不同的调参界面，并设置默认参数
    if button_name == '发送':
        self.drawbutton_list[self.button_num].bind('<Double-Button-1>',
                                                   lambda event: self.fasong_get_parameters(event))
        self.发送.para1 = 100
        self.发送.x_label = 50+60*(self.button_num%15)
        self.发送.y_label = 100
    elif button_name == 'QPSK':
        self.drawbutton_list[self.button_num].bind('<Double-Button-1>',
                                                   lambda event: self.qpsk_get_parameters(event))
        self.QPSK.para1 = 10
        self.QPSK.para2 = 100
        self.QPSK.x_label = 50 + 60 * (self.button_num % 15)
        self.QPSK.y_label = 100
    elif button_name == 'QPSK解调':
        self.drawbutton_list[self.button_num].bind('<Double-Button-1>',
                                                   lambda event: self.qpsk_get_parameters(event))
        self.QPSK解调.para1 = 10
        self.QPSK解调.para2 = 100
        self.QPSK解调.x_label = 50 + 60 * (self.button_num % 15)
        self.QPSK解调.y_label = 100
    else:
        self.drawbutton_list[self.button_num].bind('<Double-Button-1>',
                                                   lambda event: self.button_get_parameters(event))
        cmd = 'self.' + button_name + '.x_label = 50 + 60 * (self.button_num % 15)'
        exec(cmd)
        cmd = 'self.' + button_name + '.y_label = 100'
        exec(cmd)
    self.button_num += 1
```

#### 拖拽元件

用于拖拽绘图区的元件的事件

所以只能用事件触发位置相对于屏幕左上角的坐标-窗口相对屏幕左上角的坐标-canvas相对窗口左上角的坐标得到事件触发位置相对于canvas左上角的坐标，不够精确，但当时只能想到这种办法，有待改进

```python
def element_move(self,event):   #用于拖动按钮
    if self.move:
        name = event.widget['text']
        #-----------------------------------------------------
        #event.x只能得到事件触发位置相对于按钮左上角的坐标
        #所以只能用事件触发位置相对于屏幕左上角的坐标-窗口相对屏幕左上角的坐标-canvas相对窗口左上角的坐标
        #得到事件触发位置相对于canvas左上角的坐标，不够精确，但当时只能想到这种办法，有待改进
        move_x = event.x_root-self.root.winfo_x()-308
        move_y = event.y_root-self.root.winfo_y()-100
        event.widget.place(x=move_x,y=move_y)   #将元件布局至移动后的位置
        #-----------------------------------------------------
        #之前出现过，删除元件名中的\n
        element_name = ''
        for i in name:
            if i == '\n':
                pass
            else:
                element_name = element_name + i
        #------------------------------------------------------
        #将元件的坐标保存在节点中
        cmd = 'self.' + element_name + '.x_label = move_x'
        exec(cmd)
        cmd = 'self.' + element_name + '.y_label = move_y'
        exec(cmd)
        #------------------------------------------------------
```

#### 连线事件

连线事件有两个，一个绑定在canvas上，一个绑定在绘图区的按钮上

```python
def element_handle(self,event):  #绘图区按钮绑定的事件，用于连线
    if self.lianxian:
        #---------------------------------------------------------------------
        #name1用于保存上一个点击的按钮名称，name2用于保存当前点击的按钮名称
        self.element_name1 = self.element_name2
        self.element_name = event.widget['text']
        self.element_name2 = ''
        for i in self.element_name:
            if i == '\n':
                pass
            else:
                self.element_name2 = self.element_name2 + i
        #---------------------------------------------------------------------
        #grid1用于保存上一个按钮的坐标，grid2用于保存当前按钮的坐标
        self.grid1[0] = self.grid2[0]
        self.grid1[1] = self.grid2[1]
        self.grid2[0] = event.x_root-self.root.winfo_x()-308
        self.grid2[1] = event.y_root-self.root.winfo_y()-100
        #---------------------------------------------------------------------
        #self.flag初始为False，此时不会绘制线路
        #点击第一个按钮后flag变为True
        #此时点击第二个按钮后会在两个按钮之间绘制一段折线，并将两个节点连接，同时flag又变回False
        if self.flag:
            if abs(self.grid2[0] - self.grid1[0]) > abs(self.grid2[1] - self.grid1[1]):
                self.line_list.append(
                    self.canvas.create_line(self.grid1[0], self.grid1[1], self.grid2[0], self.grid1[1],
                                            arrow='last',
                                            arrowshape=(8, 15, 3)))
                self.line_list.append(
                    self.canvas.create_line(self.grid2[0], self.grid1[1], self.grid2[0], self.grid2[1],
                                            arrow='last',
                                            arrowshape=(8, 15, 3)))
            else:
                self.line_list.append(
                    self.canvas.create_line(self.grid1[0], self.grid1[1], self.grid1[0], self.grid2[1],
                                            arrow='last',
                                            arrowshape=(8, 15, 3)))
                self.line_list.append(
                    self.canvas.create_line(self.grid1[0], self.grid2[1], self.grid2[0], self.grid2[1],
                                            arrow='last',
                                            arrowshape=(8, 15, 3)))
            self.line_num += 2
        if self.flag == True:
            cmd = 'self.' + self.element_name1 + '.next = self.' + self.element_name2
            exec(cmd)
            #self.element1.next = self.elemenet2
        self.flag = not self.flag   #切换flag状态
        
        
def draw_lines(self,event):  #绘图区用于连线，绑定canvas
    if self.lianxian:
        self.grid1[0] = self.grid2[0]
        self.grid1[1] = self.grid2[1]
        self.grid2[0] = event.x
        self.grid2[1] = event.y
        if self.flag:      #flag为True时（点击过一个按钮后）可以在绘图区空白处绘制线路
            if abs(self.grid2[0] - self.grid1[0]) > abs(self.grid2[1] - self.grid1[1]):
                self.line_list.append(self.canvas.create_line(self.grid1[0], self.grid1[1], self.grid2[0], self.grid1[1], arrow='last',
                                        arrowshape=(8, 15, 3)))
                self.grid2[1] = self.grid1[1]
            else:
                self.line_list.append(self.canvas.create_line(self.grid1[0], self.grid1[1], self.grid1[0], self.grid2[1], arrow='last',
                                        arrowshape=(8, 15, 3)))
                self.grid2[0] = self.grid1[0]
            self.line_num += 1
```

#### 运行事件

绑定在运行按钮上，点击后按照链表的顺序依次运行各个元件

```python
def list_run(self,event):   #运行事件
    plt.rcParams['font.sans-serif'] = ['SimHei']  # 设置图片中的字体
    plt.rcParams['axes.unicode_minus'] = False  # 识别负号
    flag = True
    #--------------------------------------------------------------------
    #运行try中的内容，如果try中的内容报错，则会运行except中的内容
    #此处默认第一个运行发送端，产生随机序列作为节点的输出
    #如果不存在发送节点，则会运行except中的内容，将flag设为False，不再运行后续内容
    try:
        #-------------------------------------------
        #产生随机序列
        bit_list = []
        n = int(self.发送.para1)
        for i in range(n):
            bit_list.append(random.randint(0, 1))
        #------------------------------------------- 
        #将发送设为当前节点，随机序列作为节点的输出，绘制波形图并保存
        cur = self.发送
        cur.output =  bit_list
        plt.figure(figsize=(10, 5))
        plt.plot(self.发送.output, drawstyle='steps-pre')
        plt.grid()
        plt.savefig('./images/fasong.png')
    except:
        flag = False
        #此处可设置一个弹窗：没有发送端
    #--------------------------------------------------------------------
    if flag == True:
        while cur.next is not None:    #循环运行知道节点的下一个节点为空
            last = cur                 #last作为上一个节点
            cur = cur.next             
            cur.input = last.output    #将上一个节点的输出作为当前节点的输入
            #------------------------------------------------------------------
            #根据元件名称运行相应的函数，绘制并保存输出波形图
            if cur.item == 'QPSK':
                cur.output = qpskmod(cur.input,int(cur.para1),int(cur.para2))
                #输出 = 函数（输入，参数1，参数2）
                plt.figure(figsize=(10, 5))
                plt.plot(self.QPSK.output)
                plt.grid()
                plt.savefig('./images/QPSKmod.png')
            elif cur.item == 'QPSK解调':
                cur.output = qpskdemod(cur.input,int(cur.para1),int(cur.para2))
                plt.figure(figsize=(10, 5))
                plt.plot(self.QPSK解调.output)
                plt.grid()
                plt.savefig('./images/QPSKdemod.png')
            elif cur.item == 'jieshou':
                pass
            else:
                pass
            #------------------------------------------------------------------
```

#### 设置参数事件

绑定调参按钮，点击后弹出窗口进行参数设置

```python
#这部分代码写在主程序中
#如果两个元件的参数名称和数量一样的话只需要写一个
#比如此处QPSK和QPSK解调的参数名称是一样的，所以可以公用一个界面
def fasong_get_parameters(self,event):
    if self.tiaocan == True:
        try:
            os.system("python para_fasong.py") #调用para_fasong.py，打开参数设置窗口
            para1 = np.load('tmp1.npy')      #读取参数
            os.remove('tmp1.npy')            

            button_name = event.widget['text']
            cmd = 'self.' + button_name + '.para1 = para1'
            exec(cmd)      #将读取的参数保存进相应的节点内
        except:
            pass


def qpsk_get_parameters(self,event):     #大致相同，细节需要自己体会
    if self.tiaocan == True:
        try:
            os.system("python para_qpsk.py")
            para1 = np.load('tmp1.npy')
            os.remove('tmp1.npy')
            para2 = np.load('tmp2.npy')
            os.remove('tmp2.npy')

            button = event.widget['text']
            button_name = ''
            for i in button:
                if i == '\n':
                    pass
                else:
                    button_name = button_name + i

            cmd = 'self.' + button_name + '.para1 = para1'
            exec(cmd)
            cmd = 'self.' + button_name + '.para2 = para2'
            exec(cmd)
        except:
            pass
```

调用的参数设置窗口文件，此处以para_qpsk.py为例

```python
import tkinter as tk
import numpy

def fasongquit():    #绑定取消按钮
    fasong.quit()

def output():        #绑定确定按钮
    para1=input_para_1.get()
    para2=input_para_2.get()
    numpy.save('tmp1.npy',para1)
    numpy.save('tmp2.npy',para2)

    fasong.quit()


fasong = tk.Tk()

fasong.title("QPSK")

fasong.geometry("200x200")
fasong.resizable(width=False, height=False)#锁定窗口大小

label_para_1 = tk.Label(fasong, text="截止频率fc",font=("微软雅黑",10))
label_para_1.pack(side=tk.TOP,anchor="n")

input_para_1=tk.Entry(fasong)
input_para_1.pack(side=tk.TOP,pady=5,anchor='n')

label_para_2 = tk.Label(fasong, text="采样频率fs",font=("微软雅黑",10))
label_para_2.pack(side=tk.TOP,anchor="n")

input_para_2=tk.Entry(fasong)
input_para_2.pack(side=tk.TOP,pady=5,anchor='n')

b1=tk.Button(fasong, text='确认', command=output)
b1.place (x=20,y=150, anchor='w', width=60, height=40)

b2=tk.Button(fasong, text='返回', command=fasongquit)
b2.place (x=120,y=150, anchor='w', width=60, height=40)

fasong.mainloop()
```

#### 示波器

用于观察各个元件的输出波形

![image-20220227173518332](C:\Users\13735665991\AppData\Roaming\Typora\typora-user-images\image-20220227173518332.png)

##### 示波器窗口

```python
def Oscilloscope(self):
    self.min = 0
    self.max = 0
    self.now = 0
    #------------------------------------------------------------------------------------
    #建立主窗口，设置基本参数
    self.oscilloscope = tkinter.Toplevel()
    self.oscilloscope.title("示波器")
    self.oscilloscope.geometry("1000x750")
    self.oscilloscope.resizable(width=False,height=False)
    #------------------------------------------------------------------------------------
    #创建一个Frame，布局在窗口上方用于展示波形
    self.wave_frame = tkinter.Frame(self.oscilloscope, width=1000, height=500, bg='white')
    self.wave_frame.place(x=0,y=0)
    self.label_img = tkinter.Label(self.wave_frame)    #将图片以label形式布局在wave_frame中
    self.label_img.bind("<MouseWheel>", lambda event:self.wheel_handle(event)) #图片绑定滚轮事件
    self.label_img.pack()
    #------------------------------------------------------------------------------------
    #创建一个Frame，布局在窗口下方用于控制示波器
    self.ctrl_frame = tkinter.Frame(self.oscilloscope, width=1000, height=250)
    self.ctrl_frame.place(x=0,y=500)
	#---------------------------------------------------------------------------------
    #读取链表中的所有节点，存入wave_tuple
    self.wave_tuple = []
    try:
        cur = self.发送
        self.wave_tuple.append(cur.item)
        while cur.next is not None:
            cur = cur.next
            self.wave_tuple.append(cur.item)
    except:
        pass
        self.wave_tuple = tuple(self.wave_tuple) #将wave_tuple转换为元组格式，下拉菜单需要元组格式 
    self.wave_combobox = tkinter.ttk.Combobox(self.ctrl_frame, values=self.wave_tuple)
    self.wave_combobox.bind('<<ComboboxSelected>>', self.wave_combobox_handle)  #绑定选择波形事件
    self.wave_combobox.place(x=150,y=50)
	#----------------------------------------------------------------------------------
    #一些label和文本框的布局，文本框可以用于设置波形的坐标范围
    self.label_text1 = tkinter.Label(self.ctrl_frame,text='起始位置',font=('微软雅黑',10))
    self.label_text2 = tkinter.Label(self.ctrl_frame, text='结束位置', font=('微软雅黑', 10))
    self.label_text1.place(x=400,y=50)
    self.label_text2.place(x=400,y=100)
    self.text_start = tkinter.Text(self.ctrl_frame,width = 15,height = 1,font = ('微软雅黑',10))
    self.text_end = tkinter.Text(self.ctrl_frame,width = 15,height = 1,font = ('微软雅黑',10))
    self.text_start.place(x=475,y=50)
    self.text_end.place(x=475,y=100)
    self.text_start.insert("insert",self.min)
    self.text_end.insert("insert",self.max)
    self.range_button = tkinter.Button(self.ctrl_frame,text = '确定',font = ('微软雅黑',10))
    self.range_button.bind('<ButtonRelease-1>', lambda event: self.get_range())   #绑定文本框修改坐标范围事件
    self.range_button.place(x=700,y=50)
    #------------------------------------------------------------------------------------
    self.oscilloscope.mainloop()
```

##### 示波器选择显示波形

通过下拉列表选择想要观察的波形

```python
def wave_combobox_handle(self,event):
    wave_name = self.wave_combobox.get()    #得到选择的名称
    if wave_name == '发送':
        img = Image.open('./images/fasong.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)   #将label_image改为选择的图片
        self.min = 0                               #坐标范围的最小值
        self.max = len(self.发送.output)            #坐标范围的最大值
        self.x_label = range(self.max)             #得到x轴的数值
        #--------------------------------------------
        #将文本框中的内容修改为当前图片的坐标范围
        self.text_start.delete('1.0', 'end')
        self.text_end.delete('1.0', 'end')
        self.text_start.insert("insert", self.min)
        self.text_end.insert("insert", self.max)
        #--------------------------------------------
    elif wave_name == 'QPSK':                #同理
        img = Image.open('./images/QPSKmod.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)
        self.min = 0
        self.max = len(self.QPSK.output)
        self.x_label = range(self.max)
        self.text_start.delete('1.0', 'end')
        self.text_end.delete('1.0', 'end')
        self.text_start.insert("insert", self.min)
        self.text_end.insert("insert", self.max)
    elif wave_name == 'QPSK解调':            #同理
        img = Image.open('./images/QPSKdemod.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)
        self.min = 0
        self.max = len(self.QPSK解调.output)
        self.x_label = range(self.max)
        self.text_start.delete('1.0', 'end')
        self.text_end.delete('1.0', 'end')
        self.text_start.insert("insert", self.min)
        self.text_end.insert("insert", self.max)
    else:
        pass
    self.maxi = self.max       #maxi为坐标最大值，之后有用
```

##### 通过文本框调整波形坐标范围

文本框中输入坐标最大值和坐标最小值，点击确定后修改波形范围

```python
def get_range(self):
    start = self.text_start.get('0.0','end')
    end = self.text_end.get('0.0','end')    #得到坐标范围
    wave_name = self.wave_combobox.get()
    if wave_name == '发送':
        #-------------------------------------------------------------------------------
        #重新绘制波形图并保存
        plt.figure(figsize=(10, 5))
        plt.plot(self.x_label[int(start):int(end)],self.发送.output[int(start):int(end)],
                 drawstyle='steps-pre')   #draw_style='steps_pre'用于绘制方波
        plt.grid()
        plt.savefig('./images/fasong2.png')
        #-------------------------------------------------------------------------------
        self.min = start
        self.max = end           
        img = Image.open('./images/fasong2.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png) #修改label_image显示的图片
    elif wave_name == 'QPSK':
        plt.figure(figsize=(10, 5))
        plt.plot(self.x_label[int(start):int(end)],self.QPSK.output[int(start):int(end)])
        plt.grid()
        plt.savefig('./images/QPSKmod2.png')
        self.min = start
        self.max = end
        img = Image.open('./images/QPSKmod2.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)
    elif wave_name == 'QPSK解调':
        plt.figure(figsize=(10, 5))
        plt.plot(self.x_label[int(start):int(end)],self.QPSK解调.output[int(start):int(end)])
        plt.grid()
        plt.savefig('./images/QPSKdemod2.png')
        self.min = start
        self.max = end
        img = Image.open('./images/QPSKdemod2.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)
    else:
        pass
```

##### 通过鼠标滚轮改变坐标范围

鼠标置于图片上时，滚轮向上滚动放大图片，缩小范围，滚轮向下滚动缩小图片，放大范围

```python
def wheel_handle(self,event):
    wave_name = self.wave_combobox.get()
    self.max = int(self.max)
    self.min = int(self.min)
    len = self.max - self.min
    self.now = int(self.min)+len*(event.x-162)/713
	#-------------------------------------------------------------------
    #示波器全长1000像素点，波形图坐标最小出在162，坐标最大处在875，长度713
    #使鼠标滚轮滚动时图片以鼠标位置为中心放大缩小
    if event.delta > 0:   #滚轮向上滚动，图片放大，坐标范围变为原来的3/4
        self.min = int(self.min + len * (event.x - 162) / 713 / 4)
        self.max = int(self.max - len * (875 - event.x) / 713 / 4)
        #通过计算得到的坐标最小值和最大值的变化方法
        if((self.max-self.min)<10):  #波形图至少有十个点
            self.max = int(self.now + 10 * (875 - event.x) / 713)
            self.min = int(self.now - 10 * (event.x - 162) / 713)
        self.text_start.delete('1.0', 'end')
        self.text_end.delete('1.0', 'end')
        self.text_start.insert("insert", self.min)
        self.text_end.insert("insert", self.max)  #修改文本框中的内容为当前坐标范围
    #-------------------------------------------------------------------
    else:                 #滚轮向下滚动，图片缩小，坐标范围变为原来的5/4
        self.min = int(self.min - len * (event.x - 162) / 713 / 4)
        self.max = int(self.max + len * (875 - event.x) / 713 / 4)
        if self.min < 0:
            self.min = 0
        if self.max > self.maxi:
            self.max = self.maxi
        self.text_start.delete('1.0', 'end')
        self.text_end.delete('1.0', 'end')
        self.text_start.insert("insert", self.min)
        self.text_end.insert("insert", self.max)
    #--------------------------------------------------------------------
    #使用上面得到的坐标范围重画波形图并显示
    if wave_name == '发送':
        plt.figure(figsize=(10, 5))
        plt.plot(self.x_label[self.min:self.max],self.发送.output[self.min:self.max],drawstyle='steps-pre')
        plt.grid()
        plt.savefig('./images/fasong2.png')
        img = Image.open('./images/fasong2.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)
    elif wave_name == 'QPSK':
        plt.figure(figsize=(10, 5))
        plt.plot(self.x_label[self.min:self.max],self.QPSK.output[self.min:self.max])
        plt.grid()
        plt.savefig('./images/QPSKmod2.png')
        img = Image.open('./images/QPSKmod2.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)
    elif wave_name == 'QPSK解调':
        plt.figure(figsize=(10, 5))
        plt.plot(self.x_label[self.min:self.max],self.QPSK解调.output[self.min:self.max])
        plt.grid()
        plt.savefig('./images/QPSKdemod2.png')
        img = Image.open('./images/QPSKdemod2.png')
        self.image_png = ImageTk.PhotoImage(img)
        self.label_img.configure(image=self.image_png)
    else:
        pass
```

#### 保存功能

将当前绘图区的信息以文本的格式保存

##### 保存界面

保存界面，输入文件名和文件地址，地址默认为当前路径的save_file文件夹中

![image-20220227174012423](C:\Users\13735665991\AppData\Roaming\Typora\typora-user-images\image-20220227174012423.png)

```python
#基本的操作，不再赘述
def save_handle(self):
    self.save_window = tkinter.Toplevel()
    self.save_window.title("保存")
    self.save_window.geometry("500x450")
    self.save_window.resizable(width=False, height=False)

    self.label_file_name = tkinter.Label(self.save_window,text = '文件名',font = ('微软雅黑',10))
    self.text_file_name = tkinter.Text(self.save_window,width = 30,height = 1,font = ('微软雅黑',10))
    self.text_file_name.insert("insert","save1")
    self.text_file_name.place(x=150,y=100)
    self.label_file_name.place(x=100,y=100)
    self.label_file_address = tkinter.Label(self.save_window,text = '地址',font = ('微软雅黑',10))
    self.text_file_address = tkinter.Text(self.save_window,width = 30,height = 1,font = ('微软雅黑',10))
    self.text_file_address.insert("insert","./save_file/")
    self.label_file_address.place(x=100,y=200)
    self.text_file_address.place(x=150,y=200)

    self.save_determine = tkinter.Button(self.save_window,text = '确定', width = 4,font = ('微软雅黑',10))
    self.save_determine.bind('<ButtonRelease-1>', lambda event: self.save_file()) #绑定保存事件
    self.save_determine.place(x=100,y=300)
    self.save_back = tkinter.Button(self.save_window, text='返回', width=4, font=('微软雅黑', 10))
    self.save_back.bind('<ButtonRelease-1>', lambda event: self.save_quit()) #绑定退出
    self.save_back.place(x=300, y=300)

    self.save_window.mainloop()
    self.save_window.destroy()
```

##### 保存事件

```python
def save_file(self):
    empty = 0
    #--------------------------------------------------------
    #将文件名和地址结合得到保存的路径file_path
    #再创建并打开相应的txt文本
    file_name = self.text_file_name.get('0.0', 'end')
    file_address = self.text_file_address.get('0.0', 'end')
    a = file_address+file_name+'.txt'
    file_path = ''
    for i in a:
        if i == '\n':
            pass
        else:
            file_path = file_path + i
    txt = open(file_path,'w')
    #--------------------------------------------------------
    #默认从发送端开始，如果没有发送端则直接退出
    try:
        cur = self.发送
    except:
        empty = 1
        self.save_window.quit()
    #--------------------------------------------------------
    #将各项参数写入文本，以空格隔开
    if empty == 0:
        txt.write(cur.item + ' ')
        try:
            txt.write(str(cur.next.item) + ' ')
        except:
            txt.write('None' + ' ') #若当前节点的下一个节点为空，则写入None
        txt.write(str(cur.para1) + ' ')
        txt.write(str(cur.para2) + ' ')
        txt.write(str(cur.para3) + ' ')
        txt.write(str(cur.para4) + ' ')
        txt.write(str(cur.para5) + ' ')
        txt.write(str(cur.x_label) + ' ')
        txt.write(str(cur.y_label) + ' ')
        txt.write('\n')     #所有参数写入后换行，并写入下一个节点的参数
    #--------------------------------------------------------
        while cur.next is not None:
            cur = cur.next
            txt.write(cur.item + ' ')
            try:
                txt.write(str(cur.next.item) + ' ')
            except:
                txt.write('None' + ' ')
            txt.write(str(cur.para1) + ' ')
            txt.write(str(cur.para2) + ' ')
            txt.write(str(cur.para3) + ' ')
            txt.write(str(cur.para4) + ' ')
            txt.write(str(cur.para5) + ' ')
            txt.write(str(cur.x_label) + ' ')
            txt.write(str(cur.y_label) + ' ')
            txt.write('\n')

    self.save_window.quit()    #退出窗口


def save_quit(self):
    self.save_window.quit()    #退出窗口
```

#### 打开功能

读取txt文本中的内容，并在绘图区中绘制

##### 打开界面

打开界面与保存界面基本相同

![image-20220227175543793](C:\Users\13735665991\AppData\Roaming\Typora\typora-user-images\image-20220227175543793.png)

```python
def open_handle(self):
    self.open_window = tkinter.Toplevel()
    self.open_window.title("保存")
    self.open_window.geometry("500x450")
    self.open_window.resizable(width=False, height=False)

    self.label_file_name = tkinter.Label(self.open_window, text='文件名', font=('微软雅黑', 10))
    self.text_file_name = tkinter.Text(self.open_window, width=30, height=1, font=('微软雅黑', 10))
    self.text_file_name.insert("insert", "save1")
    self.text_file_name.place(x=150, y=100)
    self.label_file_name.place(x=100, y=100)
    self.label_file_address = tkinter.Label(self.open_window, text='地址', font=('微软雅黑', 10))
    self.text_file_address = tkinter.Text(self.open_window, width=30, height=1, font=('微软雅黑', 10))
    self.text_file_address.insert("insert", "./save_file/")
    self.label_file_address.place(x=100, y=200)
    self.text_file_address.place(x=150, y=200)

    self.open_determine = tkinter.Button(self.open_window, text='确定', width=4, font=('微软雅黑', 10))
    self.open_determine.bind('<ButtonRelease-1>', lambda event: self.open_file()) #绑定打开窗口
    self.open_determine.place(x=100, y=300)
    self.open_back = tkinter.Button(self.open_window, text='返回', width=4, font=('微软雅黑', 10))
    self.open_back.bind('<ButtonRelease-1>', lambda event: self.open_quit()) #绑定退出
    self.open_back.place(x=300, y=300)

    self.open_window.mainloop()
    self.open_window.destroy()
```

##### 打开事件

```python
def open_file(self):
    empty = 0
    #---------------------------------------------------------------
    #得到文件路径并打开，读取其中的内容保存在data中
    file_name = self.text_file_name.get('0.0', 'end')
    file_address = self.text_file_address.get('0.0', 'end')
    a = file_address + file_name + '.txt'
    file_path = ''
    for i in a:
        if i == '\n':
            pass
        else:
            file_path = file_path + i
    txt = open(file_path, 'r')
    data = txt.readlines()
    #---------------------------------------------------------------
    #逐行读取data中的内容，并以空格为分隔符进行分隔
    #首先读取每一行的第一个内容，得到所有节点的名称并创建相应节点
    for line in data:
        element = line.split()[0]
        cmd = 'self.' + element + ' = Node(\'' + element + '\')'
        exec(cmd)
    #---------------------------------------------------------------
    #接下来读取所有内容，并将数据保存在节点中
    for line in data:
        element = line.split()[0]   #节点名称保存在element中
        #---------------------------------------------------------------
        #若当前节点存在下一个节点，则将其与当前节点连接
        try:
            cmd = 'self.' + element + '.next = self.' + line.split()[1]
            exec(cmd)
        #若当前节点不存在下一节点，则当前节点.next = None
        except:
            cmd = 'self.' + element + '.next = None'
            exec(cmd)
        #---------------------------------------------------------------
        #读取其他各项参数
        cmd = 'self.' + element + '.para1 = ' + line.split()[2]
        exec(cmd)
        cmd = 'self.' + element + '.para2 = ' + line.split()[3]
        exec(cmd)
        cmd = 'self.' + element + '.para3 = ' + line.split()[4]
        exec(cmd)
        cmd = 'self.' + element + '.para4 = ' + line.split()[5]
        exec(cmd)
        cmd = 'self.' + element + '.para5 = ' + line.split()[6]
        exec(cmd)
        cmd = 'self.' + element + '.x_label = ' + line.split()[7]
        exec(cmd)
        cmd = 'self.' + element + '.y_label = ' + line.split()[8]
        exec(cmd)
	#-------------------------------------------------------------------
    try:
        cur = self.发送
    except:
        empty = 1
    #-------------------------------------------------------------------------------
    #若读取成功，则按照读取的链表在绘图区绘制元件和线路
    #先绘制发送端元件
    if empty == 0:
        self.drawbutton_list.append(
            tkinter.Button(self.draw_frame, text='发送', fg='black', width='5', height='2', font=('微软雅黑', 10)))
        self.drawbutton_list[0].place(x=cur.x_label,y=cur.y_label)
        self.drawbutton_list[0].bind('<ButtonRelease-1>',
                                                   lambda event: self.element_handle(event))  # 点击连线
        self.drawbutton_list[0].bind('<B1-Motion>',
                                                   lambda event: self.element_move(event))  # 移动元件
        self.drawbutton_list[0].bind('<Double-Button-1>',
                                                   lambda event: self.fasong_get_parameters(event))
        button_num = 0
        #----------------------------------------------------------------------------
        #按照链表顺序绘制元件
        while cur.next is not None:
            last = cur
            cur = cur.next
            #------------------------------------------------------------------------
            #此处由于'QPSK解调'过长，所以单独拉出来分两行显示，若还有其他名称过长的元件，可同样处理
            if cur.item == 'QPSK解调':
                self.drawbutton_list.append(
                    tkinter.Button(self.draw_frame, text='QPSK\n解调', fg='black', width='5', height='2',
                                   font=('微软雅黑', 10)))
                button_num += 1
            else:
                self.drawbutton_list.append(
                    tkinter.Button(self.draw_frame, text=cur.item, fg='black', width='5', height='2',
                                   font=('微软雅黑', 10)))
                button_num += 1
            self.drawbutton_list[button_num].place(x=cur.x_label,y=cur.y_label)
            #------------------------------------------------------------------------
			#按照读取的元件坐标绘制线路
            self.line_list.append(
                self.canvas.create_line(last.x_label, last.y_label, cur.x_label, last.y_label, arrow='last',
                                        arrowshape=(8, 15, 3)))
            self.line_list.append(
                self.canvas.create_line(cur.x_label, last.y_label, cur.x_label, cur.y_label, arrow='last',
                                        arrowshape=(8, 15, 3)))

            self.drawbutton_list[self.button_num].bind('<ButtonRelease-1>',
                                                       lambda event: self.element_handle(event))  # 点击连线
            self.drawbutton_list[self.button_num].bind('<B1-Motion>',
                                                       lambda event: self.element_move(event))  # 移动元件
			#------------------------------------------------------------------------
            #为元件绑定相应事件
            if cur.item == 'QPSK':
                self.drawbutton_list[button_num].bind('<Double-Button-1>',
                                                           lambda event: self.qpsk_get_parameters(event))
            elif cur.item == 'QPSK解调':
                self.drawbutton_list[button_num].bind('<Double-Button-1>',
                                                           lambda event: self.qpsk_get_parameters(event))
            else:
                self.drawbutton_list[button_num].bind('<Double-Button-1>',
                                                           lambda event: self.button_get_parameters(event))
			#------------------------------------------------------------------------
    self.open_window.quit() #退出窗口


def open_quit(self):
    self.open_window.quit() #退出窗口
```